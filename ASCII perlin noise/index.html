<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <title>ASCII Perlin Noise Optimizado</title>
    <style>
      body {
        margin: 0;
        background: rgb(0, 0, 0);
        overflow: hidden;
      }
      canvas {
        display: block;
        width: 100vw;
        height: 100vh;
        image-rendering: pixelated;
        background: rgb(0, 0, 0);
      }
    </style>
  </head>
  <body>

    <h1 style="z-index: 10 !important; position: absolute; font-family: Verdana, Geneva, Tahoma, sans-serif; color: white; justify-self: center; align-self:first baseline">Bienvenido a Esfera Sintética</h1>
    <p style="margin-top: 10rem; z-index: 10 !important; position: absolute; font-family: Verdana, Geneva, Tahoma, sans-serif; color: white; justify-self: center; align-self:first baseline">Una experiencia inmersiva con fútbol</p>
    
    <canvas id="ascii"></canvas>

    <script>
      const canvas = document.getElementById("ascii");
      const ctx = canvas.getContext("2d");

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      window.addEventListener("resize", resize);
      resize();

      // --- Perlin Noise simple ---
      function fade(t) {
        return t * t * t * (t * (t * 6 - 15) + 10);
      }
      function lerp(a, b, t) {
        return a + t * (b - a);
      }
      const perm = new Uint8Array(512);
      for (let i = 0; i < 256; i++) perm[i] = i;
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [perm[i], perm[j]] = [perm[j], perm[i]];
      }
      for (let i = 0; i < 256; i++) perm[i + 256] = perm[i];

      function grad(hash, x, y) {
        const h = hash & 3;
        return ((h & 1) === 0 ? x : -x) + ((h & 2) === 0 ? y : -y);
      }

      function perlin(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = fade(x);
        const v = fade(y);
        const A = perm[X] + Y;
        const B = perm[X + 1] + Y;
        return lerp(
          lerp(grad(perm[A], x, y), grad(perm[B], x - 1, y), u),
          lerp(grad(perm[A + 1], x, y - 1), grad(perm[B + 1], x - 1, y - 1), u),
          v
        );
      }

      // --- Animación ---
      const chars = " .:-*=+#%@";
      const cellW = 12;
      const cellH = 20;

      let t = 0;
      let dirX = Math.random() * 2 - 1;
      let dirY = Math.random() * 2 - 1;

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.font = `${cellH}px monospace`;
        ctx.textBaseline = "top";

        const cols = Math.floor(canvas.width / cellW);
        const rows = Math.floor(canvas.height / cellH);

        // Valores de color base (RGB)
        const grayMin = 20;
        const grayMax = 30;
        const blueR = 100;
        const blueG = 150;
        const blueB = 255;

        // Umbral de transición (ajustable)
        const transitionThreshold = 0.4;

        for (let y = 0; y < rows; y++) {
          for (let x = 0; x < cols; x++) {
            const n = perlin(x * 0.02 + t * dirX, y * 0.02 + t * dirY);
            const val = (n + 1) / 2; // Rango 0-1
            const idx = Math.floor(val * (chars.length - 1));
            const ch = chars[idx];

            // Sección de Colorear (MODIFICADA)
            let r, g, b;

            if (val < transitionThreshold) {
              // Rango de ruido bajo: solo gris
              const grayVal = Math.floor((val / transitionThreshold) * grayMax);
              r = g = b = grayVal;
            } else {
              // Rango de ruido alto: mezcla de gris y azul
              const transitionVal =
                (val - transitionThreshold) / (1 - transitionThreshold);
              r = Math.floor(lerp(grayMax, blueR, transitionVal));
              g = Math.floor(lerp(grayMax, blueG, transitionVal));
              b = Math.floor(lerp(grayMax, blueB, transitionVal));
            }

            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.fillText(ch, x * cellW, y * cellH);
          }
        }

        // Pequeño drift direccional aleatorio
        if (Math.random() < 0.01) {
          dirX += (Math.random() - 0.5) * 0.2;
          dirY += (Math.random() - 0.5) * 0.2;
          const len = Math.sqrt(dirX * dirX + dirY * dirY);
          dirX /= len;
          dirY /= len;
        }

        t += 0.002;
        requestAnimationFrame(animate);
      }

      animate();
    </script>
  </body>
</html>
